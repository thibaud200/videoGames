import requests
import logging
import time
import json
from typing import List, Optional, Dict, Any
from urllib.parse import urljoin
from config.config_loader import ConfigLoader
from gog.models import GOGGame, GOGUserProfile

class GOGAPIException(Exception):
    """Exception personnalisée pour l'API GOG"""
    pass

class GOGPersonalClient:
    """Client GOG simplifié pour usage personnel - sans OAuth complexe"""
    
    def __init__(self, config_file: str = "config/gog.properties"):
        self.config = ConfigLoader(config_file)
        
        # Identifiants personnels
        self.client_id = self.config.get("gog.client.id", "").strip()
        self.client_secret = self.config.get("gog.client.secret", "").strip()
        self.galaxy_user_id = self.config.get("gog.galaxy.user_id", "").strip()
        
        # URLs
        self.store_base_url = self.config.get("gog.store.base_url", "https://www.gog.com")
        self.embed_base_url = self.config.get("gog.embed.base_url", "https://embed.gog.com")
        self.timeout = self.config.get_int("gog.api.timeout", 30)
        
        # Retry configuration
        self.max_retries = self.config.get_int("gog.retry.max_attempts", 3)
        self.retry_delay = self.config.get_int("gog.retry.delay_seconds", 2)
        
        # Session HTTP
        self.session = requests.Session()
        self.session.timeout = self.timeout
        
        # Headers par défaut pour simuler un navigateur
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
            'Accept': 'application/json, text/plain, */*',
            'Accept-Language': 'fr-FR,fr;q=0.9,en;q=0.8',
            'Accept-Encoding': 'gzip, deflate, br',
            'Connection': 'keep-alive',
            'Sec-Fetch-Dest': 'empty',
            'Sec-Fetch-Mode': 'cors',
            'Sec-Fetch-Site': 'same-origin'
        })
        
        logging.info("GOGPersonalClient initialisé avec succès")
    
    def _make_request(self, url: str, params: Dict[str, Any] = None, 
                     headers: Dict[str, str] = None) -> Dict[str, Any]:
        """Effectue une requête HTTP avec retry automatique"""
        request_headers = self.session.headers.copy()
        if headers:
            request_headers.update(headers)
        
        for attempt in range(self.max_retries):
            try:
                logging.debug(f"Requête GOG: {url} (tentative {attempt + 1})")
                response = self.session.get(url, params=params or {}, headers=request_headers)
                response.raise_for_status()
                
                return response.json()
                
            except requests.exceptions.RequestException as e:
                logging.warning(f"Erreur requête GOG (tentative {attempt + 1}): {e}")
                if attempt == self.max_retries - 1:
                    raise GOGAPIException(f"Échec de la requête après {self.max_retries} tentatives: {e}")
                time.sleep(self.retry_delay)
        
        raise GOGAPIException("Erreur inattendue lors de la requête")
    
    def get_user_data_from_web(self) -> Optional[GOGUserProfile]:
        """
        Récupère les données utilisateur via l'endpoint web GOG
        ATTENTION: Nécessite d'être connecté à GOG dans le navigateur
        """
        try:
            url = f"{self.store_base_url}/userData.json"
            data = self._make_request(url)
            
            if data:
                return GOGUserProfile.from_dict(data)
            
            return None
            
        except Exception as e:
            logging.error(f"Erreur lors de la récupération des données utilisateur: {e}")
            logging.info("Astuce: Vous devez être connecté à GOG.com dans votre navigateur")
            return None
    
    def search_games_public(self, query: str = "", limit: int = 50, 
                           search_type: str = "games") -> List[Dict[str, Any]]:
        """
        Recherche publique dans le catalogue GOG (ne nécessite pas d'authentification)
        """
        try:
            url = f"{self.embed_base_url}/games"
            params = {
                'limit': limit,
                'order': 'desc:trending'
            }
            
            if query:
                params['search'] = query
            
            data = self._make_request(url, params)
            games = data.get('products', [])
            
            logging.info(f"Trouvé {len(games)} jeux dans le catalogue GOG")
            return games
            
        except Exception as e:
            logging.error(f"Erreur lors de la recherche publique: {e}")
            raise GOGAPIException(f"Impossible d'effectuer la recherche: {e}")
    
    def get_game_details_public(self, game_id: int) -> Optional[Dict[str, Any]]:
        """
        Récupère les détails publics d'un jeu GOG
        """
        try:
            url = f"{self.embed_base_url}/games/{game_id}"
            data = self._make_request(url)
            
            logging.info(f"Détails récupérés pour le jeu ID {game_id}")
            return data
            
        except Exception as e:
            logging.error(f"Erreur lors de la récupération des détails du jeu {game_id}: {e}")
            return None
    
    def get_owned_games_mock(self) -> List[GOGGame]:
        """
        Version mock pour tester - remplace par votre implémentation réelle
        """
        logging.warning("Utilisation de données mock - remplacez par votre implémentation")
        
        # Données d'exemple - remplacez par vos vraies données
        mock_games = [
            {
                'id': 1207658924,
                'title': 'The Witcher 3: Wild Hunt',
                'category': 'game',
                'worksOn': {'windows': True, 'mac': True, 'linux': True},
                'tags': ['RPG', 'Action', 'Fantasy'],
                'releaseDate': '2015-05-19'
            },
            {
                'id': 1207658930,
                'title': 'Cyberpunk 2077',
                'category': 'game',
                'worksOn': {'windows': True, 'mac': False, 'linux': False},
                'tags': ['RPG', 'Action', 'Sci-fi'],
                'releaseDate': '2020-12-10'
            }
        ]
        
        games = []
        for game_data in mock_games:
            game = GOGGame.from_dict(game_data)
            games.append(game)
        
        logging.info(f"Données mock: {len(games)} jeux")
        return games
    
    def export_games_to_json(self, games: List[GOGGame], filename: str = "gog_games.json"):
        """
        Exporte la liste des jeux vers un fichier JSON
        """
        try:
            games_data = []
            for game in games:
                game_dict = {
                    'id': game.id,
                    'title': game.title,
                    'category': game.category,
                    'platforms': game.get_platforms(),
                    'tags': game.tags,
                    'release_date': game.release_date,
                    'url': game.url
                }
                games_data.append(game_dict)
            
            with open(filename, 'w', encoding='utf-8') as f:
                json.dump(games_data, f, indent=2, ensure_ascii=False)
            
            logging.info(f"Liste des jeux exportée vers {filename}")
            
        except Exception as e:
            logging.error(f"Erreur lors de l'export: {e}")
    
    def import_games_from_json(self, filename: str = "gog_games.json") -> List[GOGGame]:
        """
        Importe la liste des jeux depuis un fichier JSON
        """
        try:
            with open(filename, 'r', encoding='utf-8') as f:
                games_data = json.load(f)
            
            games = []
            for game_data in games_data:
                # Reconvertir les plateformes en format GOG
                platforms = game_data.get('platforms', [])
                works_on = {
                    'windows': 'Windows' in platforms,
                    'mac': 'Mac' in platforms,
                    'linux': 'Linux' in platforms
                }
                game_data['worksOn'] = works_on
                
                game = GOGGame.from_dict(game_data)
                games.append(game)
            
            logging.info(f"Liste des jeux importée depuis {filename}: {len(games)} jeux")
            return games
            
        except Exception as e:
            logging.error(f"Erreur lors de l'import: {e}")
            return []
